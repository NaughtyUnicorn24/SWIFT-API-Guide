# 1. Introduction

A recent [survey](https://smartbear.com/resources/ebooks/the-state-of-api-2019-report "The State of API 2019") performed by SmartBear, a leading company in application programming interfaces (APIs) included more than 3000 responses from developers, architects, and quality assurance (QA) professionals.

The result of the survey reveals the importance of the **experience for developers** when consuming APIs that is, their usability, their **quality**, and how **internal organisation API design guidelines** help to **harmonise** the consumer's experience.

This document describes SWIFT-specific guidelines that should be followed when building an Open API.

SWIFT's Open APIs are based on the REST architecture:
- **URLs** define the query interface of the API that is, all of the endpoints that can be used to either access data that is exposed or to trigger actions.
- **Representations** of the resources are exchanged between the consumer and the provider. Those representations are sent through the HTTP body of the request/response and have a specific format that is JSON or XML defined in the Content-Type header of the associated request/response.
- **HTTP Verbs** that is, POST, GET/HEAD, PUT/PATCH, and DELETE define the actions that can be performed on the resources.
- All interactions are **Stateless**, meaning that the server does not store any context information associated with the consumer. State dependencies limit and restrict the scalability/elasticity of the APIs.

An API exposes a back-end service or system to a consumer.

![back-end-service.png](./back-end-service.png)

*APIs expose a back-end service or system*

For more information about REST, check Roy Thomas Fielding's [dissertation](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).

## 1.1. Terminology

### End-Users

They do not consume APIs directly, but use a client application and/or a website.

For example, a user using a weather application to see weather forecasts will consume weather data from the API **through** the application.

### Client Applications

Applications and/or websites used to access APIs.

They send requests to the APIs and receive responses back.

Client applications and/or websites serve the end-users.

### OAuth 2.0

The industry-standard protocol for **authorisation**.

[OAuth 2.0](https://oauth.net/2) provides **authorisation flows** for web applications, desktop applications, mobile applications, and Internet of Things (IoT) applications.

SWIFT uses OAuth 2.0 for both **Cloud-based APIs** and **MV-SIPN-based APIs**.

OAuth 2.0 delivers **access tokens** that can then be used to access APIs on behalf of the user.

### Access Token

The "thing" used by client applications to make API requests **on behalf of** an end-user.

An [access token](https://www.oauth.com/oauth2-servers/access-tokens) represents the authorisation of a specific client application to access specific parts that is, the **scope** of the OAuth access token of a user's data.

The OAuth access token must always be sent through an **HTTP** over **TLS** that is, HTTPS secure connection using the **HTTP Bearer Authentication** mechanism.

### HyperText Transfer Protocol (HTTP)

Stateless application-level protocol for distributed, collaborative, hypertext information systems.

[HTTP](https://tools.ietf.org/html/rfc7231) is at the heart of REST APIs.

### Transport Layer Security (TLS)

The primary goal of [TLS](https://tools.ietf.org/html/rfc8446) is to provide a secure channel between two communicating peers.

The only requirement from the underlying transport is a reliable, in-order data stream.

The TLS protocol provides authentication, confidentiality and integrity.

The TLS protocol can be implemented as either one-way or two-way:
- In one-way TLS, only the client validates the server to ensure that it receives data from the intended server. One-way TLS is always used between client applications and the API gateway.
- In two-way TLS, the client and the server authenticate each other to ensure that both parties involved in the communication are trusted. Two-way TLS is always used between the API gateway and the back-end systems.

### (HTTP) Bearer Authentication

Also called Token Authentication.

It is an HTTP [authentication scheme](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) that involves security tokens called bearer tokens.

The name "bearer authentication" can be understood as *give access to the bearer of this token*.

The bearer token is a cryptic string generated by the **/token** API proxy in response to a login request.

The client application must send this token in the Authorization header when making requests to protected resources:

```text
Authorization: Bearer <token>
```

### Cloud-based APIs

APIs accessible through the public Internet that is, the API Gateway hosting these APIs is installed in the cloud.

### OPC-based APIs

Also called On-Premises APIs that is, the API Gateway hosting these APIs is installed inside SWIFT's OPCs.

Either APIs accessible through SWIFT's Multi-Vendor Secure IP Network (MV-SIPN), or APIs accessible through the public Internet BUT with additional security: two-way TLS and bearer tokens.

### API Management Platform

Set of tools for creating and publishing APIs:
- API Gateway
- API Publishing Tools
- Developer Portal
- API Reporting and Analytics
- API Monetisation

### API Gateway

Server that acts as an API front-end, receiving API requests, enforcing throttling and security policies, passing requests to the back-end service, and passing the response back to the requester.

An API gateway can also provide functionalities such as:
- A transformation engine to orchestrate and modify the requests and responses on the fly.
- Collecting analytics data.
- Providing caching.
- Providing support for authentication and authorisation.
- Providing support for security, auditing, and regulatory compliance.

### API Publishing Tools

Collection of tools used to:
- Define APIs using the OpenAPI 3.0 Specification (OAS 3.0).
- Collaborate on the definition of new APIs.
- Generate API documentation (for publication on the Developer Portal).
- Generate Client SDK and Server Stubs code in several programming languages.
- Coordinate the overall API Lifecycle.

[SwaggerHub](https://swagger.io/tools/swaggerhub) is the API publishing tool used within SWIFT.

### Developer Portal

The **one** source of information about all APIs published by SWIFT.

SWIFT's Developer Portal provides:
- API catalogue.
- API overview (value proposition, latest updates, use cases).
- Developer-friendly reference documentation.
- Client SDKs and other collaterals, such as JSON Schemas and detailed specifications.
- API sandboxes to test APIs.
- The ability to subscribe to APIs and manage consumer keys/secrets that is, OAuth 2.0 Client ID and Client Secret.
- The ability to request support.

The Developer Portal is similar to **SWIFT's Download Center** in that it contains the **released products related to APIs**.

The content of the Developer Portal is **accessible to anyone** who has a swift.com account or who has created a Developer Portal account.

SwaggerHub functions as a **Social Network for APIs**. It enables users inside and outside of SWIFT to **collaborate on the design of new or existing APIs**.

The access to the API specifications in SwaggerHub is controlled, and users must **ask permission to collaborate** on the API specifications they are interested in.

### API Reporting and Analytics

Monitor API usage and load (for example, overall hits, completed transactions, number of data objects returned, amount of compute time and other internal resources consumed, volume of data transferred).

Can include real-time monitoring of APIs with alerts raised directly or by means of a higher-level network management system.

The reporting and analytics functionality can be used to optimise the API offering within an organization's overall continuous improvement process, and for defining service-level agreements (SLAs) for APIs.

### API Monetisation

Provide support for charging access to commercial APIs.

Set up pricing rules based on usage, load and, functionality.

### Back-end System

The system implementing the API.

### API Consumers

Developers creating mobile applications and/or websites for end-users.

They consume APIs by integrating them into their applications and/or websites.

They are the main users of the Developer Portal, where they can register their applications to gain access to the APIs they need.

**What we expect from a consumer:**
- **Must** respect the API design guidelines.
- **Should** ignore fields that are not recognised in a response.
- **Should** be as specific as possible when consuming versions.
- **Should** expect the API to be stateless.
- **Should** utilise resource links provided in response payload in preference to self-generated URLs.
- **Could** ask for additional data and/or functionality. There may be additional data and/or functionality that the API can offer to make it more useful to consumers. Valid reasons to ask for API changes are, for instance:
  - The API does not support a (new) widely used API standard.
  - The API only offers some information as part of a larger set.
- **Should not** expected dramatic changes in an API just because that would suit their needs. APIs may already have other consumers and changes might not be suitable for them.

### API Providers

Expose data and/or functionality by creating and operating APIs.

They typically use an API Management Platform to make their APIs available to others.

They use the Developer Portal to provide information and documentation about their APIs for the API consumers.

# 2. Types of APIs

When designing a new API, you should always ask yourself: *"Who am I designing it for?"*.

Considering the audience of an API will guide its architecture, network configuration, and security measures.

SWIFT normally considers four types of APIs:

| Term | Explanation |
| --- | --- |
| Open APIs | Accessible by anybody who wishes to sign up, and are easily accessible to the wider population on the web and mobile developers, but will often have a vetting service to prevent criminal acts. Open does not necessarily mean free. They should be secure, because they are open to the world. |
| Partner APIs | Open APIs designed for partners. They can hold optimisations requested by partners to make them easier to integrate into their processes. They should be secure, because they are open to the world. |
| Private APIs | Allow an organisation and their contractors to access back-end data and functionality to develop new applications which can then be distributed publicly. They help to reduce development times and internal resources needed by stopping siloed applications from being built from scratch and creating a common center of internal software assets. |
| Internal APIs | Only accessible within an organisation because systems are built and managed by employees. They are ideally not accessible by public Internet. They provide a portal in which cross-departmental projects can be conducted, allowing more flexibility than legacy systems. |

Source: [APIs – Open vs Private vs Internal](https://www.linkedin.com/pulse/apis-open-vs-private-internal-thomas-kaufmann).

This document is applicable to all types of APIs.

The guidelines can differ per type.

The differences are documented as follows:

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

(First row): The type of API it applies to:
- Internal
- Private
- Partner
- Open

(Second row): What is enforced for this type of API:
- Must (*required*) if the criteria must be met.
- Should (*highly recommended*) if the criteria must be met, but it is temporarily allowed to deviate if valid reasons are provided.
- Could (*optional*) if the criteria does not have to be met, but it is preferable to do so.

# 3. Security

This chapter describes the security features used by APIs.

## 3.1. North-bound Security

End-users must always be authenticated and authorised before using APIs.

**Authentication** involves validating end-users' credentials (for example, username and password) to verify their identity. It answers the question *are you who you say you are*.

**Authentication** can be implemented either using a swift.com username and password or Public Key Infrastructure (PKI) identification (for example, using digital certificates).

**Authorisation** is the process to determine whether the authenticated user should have access to the particular resources. It answers the question *are you allowed to do what you want to do*.

**Authorisation** can be implemented using [OAuth 2.0](https://oauth.net/2) and [HTTP Bearer Authentication](https://swagger.io/docs/specification/authentication/bearer-authentication).

See *3.3. Authentication and Authorisation (auth/auth)* and *3.4. Tokens* for more details.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

## 3.2. South-bound Security

No one should be allowed to bypass the security of SWIFT's API Gateway (for example, OAuth 2.0 and HTTP Bearer Authentication).

Back-end data and functionalities exposed should only be accessed via SWIFT's API Gateway. Every other connection should be rejected and logged.

To achieve this, implement a [two-way TLS connection](https://en.wikipedia.org/wiki/Mutual_authentication) between SWIFT's API Gateway and each one of the back-end servers.

For *production* and *developer portal* environments, the digital certificate must be signed by a Trusted Certificate Authority (CA) such as SWIFTNet CA, for example.

For *test* environments, the digital certificate can be a [self-signed certificate](https://en.wikipedia.org/wiki/Self-signed_certificate).

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

## 3.3. Authentication and Authorisation (AuthN/AuthZ)

OAuth 2.0 access tokens are sent as bearer tokens through [HTTP Bearer Authentication](https://swagger.io/docs/specification/authentication/bearer-authentication/).

OAuth 2.0 provides to Client Applications a **Secure Delegated Access** to Resource Servers on behalf of a Resource Owner.

OAuth 2.0 involves **Authorisation**, not **Authentication**.

OAuth 2.0 access tokens should be JSON Web Tokens (JWTs) and should contain the following information:
- "sub" (**subject** claim) containing information about the Resource Owner.
- "cid" (**client** identifier claim) containing information about the Client Application.
- "iss" (**issuer** claim) containing information about the Authorisation Server.
- "aud" (**audience** claim) containing information about the Resource Server.
- "exp" (**expiration time** claim) containing the absolute expiration time (for example, EPOCH/POSIX time).

OAuth 2.0 access tokens are delivered by the **/token** endpoint and can be inactivated by the **/revoke** endpoint.

The mechanism used to acquire an OAuth 2.0 access token varies, depending on the type of API Gateway that is used.

### 3.3.1. APIs Exposed through the (Public) Cloud API Gateway

```text
POST /token HTTP/1.1
Host: api.swift.com
Authorization: Basic <base64Encode(<clientId> + ":" + <clientSecret>)>
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=<username>&password=<password>
```

### 3.3.2. APIs Exposed through the (Private) On-Premises (SWIFTNet/MV-SIPN) API Gateway

```text
POST /token HTTP/1.1
Host: api.swiftnet.sipn.swift.com
Authorization: Basic <base64Encode(<clientId> + ":" + <clientSecret>)>
Content-Type: application/x-www-form-urlencoded
X-SRCNW: MV_SIPN

grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&scope=<scope>&assertion=<assertion>
```

## 3.4. Tokens

There are two types of tokens.

| Token Type | Description |
| --- | --- |
| Opaque | Token is encrypted and consists of a random sequence of alphanumeric characters with no inherent meaning and/or structure. Its contents cannot be viewed by other parties. |
| Transparent | Token is not encrypted, but can be encoded and digitally signed. Its contents can be read by anyone (for example, JSON Web Token/JWT). |

SWIFT currently uses opaque tokens as bearer tokens, but may move to transparent tokens by using [JWT](https://jwt.io).

# 4. Naming Conventions

Naming conventions are fundamental to harmonise the API consumers' experience.

Companies usually do not have one API, but can have several hundreds or thousands of APIs, with multiple versions of the same API.

Some of the below sections are based on conventions from the [JSON API Specification](https://jsonapi.org).

## 4.1. Language

APIs must be written in [Plain English](https://en.wikipedia.org/wiki/Plain_English).

This includes:
- URLs (including Path Parameters and Query Parameters)
- HTTP Headers
- HTTP Bodies
- Documentation

This rule does not apply for APIs that make use of international characters (for example, TSS API using Chinese or French vocabulary).

To make sure SWIFT APIs are internationalised, [UTF-8](https://en.wikipedia.org/wiki/UTF-8) encoding should be used.

The default encoding for application/json payloads is UTF-8.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Must | Must | Must |

## 4.2. Uniform Resource Locator (URL)

An API is a set of resources uniquely identified by their URLs.

Having a logical structure for URLs helps to organise APIs and to make them easy to understand and easy to consume.

The structure of a URL (for example, https://api.example.com/user-management/users?country=BE) is:
- Protocol (https)
- Resource Name (api.example.com/user-management/users?country=BE)

The structure of a Resource Name (for example, api.example.com/user-management/users?country=BE) is:
- Hostname (api.swift.com)
- Path (/user-management/users)
- Query String (country=BE)

The structure of a Hostname (for example, api.swift.com) is:
- Subdomain (api)
- Domain (swift)
- Top-Level Domain/TLD (com)

### 4.2.1. Protocol

HTTPS that is, HTTP over TLS must always be used, because it provides:
- **Confidentiality** of the data exchanged between the Client Application and the API Gateway.
- **Integrity** of the data exchanged between the Client Application and the API Gateway.
- **Authentication** of the API Gateway.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

### 4.2.2. Hostname

The hostname identifies the targeted environment.

#### 4.2.2.1. Public Cloud Environments

| Environment | Hostname |
| --- | --- |
| Production | api.swift.com |
| Developer Portal | sandbox.swift.com |
| Test | swift-dev-dev.apigee.net |

#### 4.2.2.2. Private On-Premises Environments

| Environment | Hostname |
| --- | --- |
| Production | api.swiftnet.sipn.swift.com |
| Test | api-test.swiftnet.sipn.swift.com |

### 4.2.3. Path

The path is the unique identifier of a resource.

Paths must contain **NOUNS** and not **VERBS** (for example, /ibans/{iban}/validity is valid, but /get-iban-validity/{iban} is not valid).

There are sometimes exceptions to this rule, and **VERBS** may be used if they make the API's intent **clearer** (for example, /swift-translation-api/v1/translate instead of /swift-translation-api/v1/translation-result).

| Type of Resource | Path |
| --- | --- |
| Collection (for example, all customers) | /customers |
| Single (for example, one specific customer) | /customers/{customerId} |
| Sub-Collection (for example, all accounts of one specific customer) | /customers/{customerId}/accounts |

Your API consumers do not necessarily speak SWIFT's language.

When possible, try to avoid using SWIFT-specific terms.

Following are some sample URLs:
- https://api.example.com/user-management/users/123
- https://api.example.com/user-management/users/123/orders
- https://api.example.com/user-management/users/123/orders/32/prepare

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

### 4.2.4. Query String

The query string is usually used for filtering and/or sorting a collection of resources.

Filtering techniques are used to reduce the amount of data returned by the API, which results in:
- Reduced bandwidth consumption
- Reduced latency
- Improved response time

Filtering and sorting are done based on some resource attributes (for example, region, year, month, day, and so on).

For example, https://api.example.com/user-management/users?country=BE&age%3e40&sort=lastName will return all users:
- Located in Belgium
- Whose age is greater than 40
- Sorted by last name

### 4.2.5. Best Practices

The following best practices will ensure that all SWIFT APIs are harmonised.

#### 4.2.5.1. Use Nouns to Represent Resources

Resources are "things" that is, nouns, not actions that is, verbs.

Think of resources as being *objects*. They contain *properties* (to describe their *state*) and *methods* (to describe their *behaviour*).

REST APIs are composed of four distinct resource archetypes:
- Document
- Collection
- Store
- Controller

For the moment, only Document and Collection should be used.

If later there is a clear use case for either Store or Controller, SWIFT will update the document accordingly.

#### 4.2.5.2. Use Forward Slash to Indicate a Hierarchical Relationship

The forward slash character is used in the path portion of the URL to indicate a hierarchical relationship between resources.

For example, the "/customers/{customerId}/accounts/{accountId}" URL uniquely identifies the account {accountId} of the customer {customerId}.

#### 4.2.5.3. Do Not Use a Trailing Forward Slash in URLs

As last character of a URL's path, a forward slash does not add any semantic value and causes confusion.

```text
Valid:          https://api.example.com/user-management/users
Invalid:        https://api.example.com/user-management/users/
```

#### 4.2.5.4. Use Hyphens to Improve the Readability of URLs

Use hyphens to split words in order to improve the readability of URLs.

```text
Valid:          https://api.example.com/user-management
Invalid:        https://api.example.com/usermanagement
```

#### 4.2.5.5. Never Use Underscores in URLs

Using underscores instead of hyphens is not recommended.

Depending on the font used, underscores can either become partially obscured or completely hidden, which dramatically reduces the readability of URLs.

```text
Valid:          https://api.example.com/user-management
Invalid:        https://api.example.com/user_management
```

#### 4.2.5.6. Always Use Lower-case Letters in URLs

[RFC 3986](https://www.ietf.org/rfc/rfc3986.txt) defines URLs as case-sensitive except for:
- The scheme (for example, https is the same as HTTPS)
- The host (for example, api.example.com is the same as API.EXAMPLE.COM)

Having a part of the URL being case-sensitive and another part of the same URL being case-insensitive creates confusion.

To avoid confusion, always use lower-case letters in URLs.

```text
Valid:          https://api.example.com/my-folder/my-document
Invalid:        https://api.example.com/myFolder/myDocument
```

#### 4.2.5.7. Never Use File Extensions in URLs

If you want to highlight the media type of a resource in an API, do not use file extensions in URLs, but use the Content-Type HTTP response header instead.

Resources should always be independent of their representations (for example, application/json, application/xml).

```text
Valid:          https://api.example.com/my-folder/my-document
Invalid:        https://api.example.com/my-folder/my-document.json
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Should | Should | Should |

## 4.3. JSON

Always use [snake case](https://en.wikipedia.org/wiki/Snake_case) for objects and properties.

Business requests and responses use the [ISO 20022 Universal Financial Industry Message Scheme](https://www.iso20022.org/).

```text
Example of an ISO 20022 JSON message:

{
  "activity_report": {
    "related_message_reference": {
      "creation_date_time": "2009-09-09T11:37:00",
      "identification": "ARRMessage24"
    },
    "report": [ {
      "transaction_identification": "01190799181-6940-48",
      "reported_entity": [ {
        "bic": "ADIABE22"
      } ],
      "reported_item": [ {
        "activity": {
          "message_name": "tsmt.011.001.02"
        },
        "initiator": {
          "bic": "SWHQBEBB"
        },
        "date_time": "2009-09-06T08:54:00"
      }, {
        "activity": {
          "message_name": "tsmt.020.001.02"
        },
        "initiator": {
          "bic": "ADIABE22"
        },
        "date_time": "2009-09-06T08:52:00"
      } ]
    } ],
    "report_identification": {
      "creation_date_time": "2009-09-09T11:38:00",
      "identification": "ARPMessage25"
    }
  },
  "@xmlns": "urn:iso:std:iso:20022:tech:xsd:tsmt.002.001.04"
}
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Must | Should | Must |

# 5. Version Strategy and Support

*Change is the only constant in life. One's ability to adapt to those changes will determine your success in life.*

[Benjamin Franklin](https://en.wikipedia.org/wiki/Benjamin_Franklin)

## 5.1. Semantic Versioning

*source: https://semver.org*

Given a version number MAJOR.MINOR.PATCH, increment the:
- MAJOR version when you make incompatible API changes.
- MINOR version when you add functionality in a backward-compatible manner.
- PATCH version when you make backward-compatible bug fixes.

## 5.2. What to Version

It is fundamental to make the distinction between three types of versioning in the SWIFT API world:
- API versioning (what we are describing here).
- API specification versioning that is, the version of the API specification in SwaggerHub.
- API proxy versioning that is, the version of the source code deployed in the API gateway to support the API.

## 5.3. When to Version

When an incompatible change is made to an API, its MAJOR version number must be incremented (for example, from v1 to v2).

Backward-compatible changes (either adding new functionality or fixing a bug) do not require you to increment the major version of the API.

## 5.4. How to Version

Increment the MAJOR version number when a "breaking change" is made to the API (either functional breaking change or bug-fix breaking change).

Increment the MINOR version number when a functional "non-breaking change" is made to the API.

Increment the PATCH version number when a bug-fix "non-breaking change" is made to the API.

### 5.4.1. Breaking versus Non-Breaking Changes

In general:
- **Breaking changes** change the API contract. The API cannot be used in the same way as it was used before the change. Something was removed or something existing was changed.
- **Non-breaking changes** are changes that do not change the API contract. The API can still be used in the way it was used before from the consumers' perspective. Often something is added, but nothing is removed.

Examples of breaking changes:
- Change the format of a response (for example, from application/xml to application/json).
- Change to the structure of an error response (API consumers usually implement some logic for parsing error responses).
- Change a type in the response (for example, from int to float).
- Change the name of a property (for example, from name to firstName).
- Mandatory resource added to an existing workflow.
- Remove an endpoint/resource from an existing API.
- Remove support for a Content-Type (in requests and/or responses).

Examples of non-breaking changes:
- New properties added to a response (new properties should just be skipped by the existing API consumers).
- New supported Content-Type formats (in requests and/or responses).
- New supported Content-Language formats (in requests and/or responses).
- New link to other resources (HATEOAS).
- Change the technical working that is, the implementation of an API without changing the contract/interface (for example, changing the sort algorithm to improve performance should NOT change the API specification).
- Change API Proxy configuration (for example, rate limiting rules, quota policy, and so on).

### 5.4.2. URL Versioning

Because there are no standards for API versioning, SWIFT has decided to adopt the URL versioning approach that is, specifying the API version in the URL.

The version is specified using the vXXX syntax where the version tag is added **after** the service name.

The format of a SWIFT API URL is:

```text
https://.../<service-name>/v<major-version>/<entity-name>.
```

```text
Valid:          https://api.swiftnet.sipn.swift.com/swift-preval/v1/accounts/verification
Invalid:        https://api.swiftnet.sipn.swift.com/v1/swift-preval/accounts/verification
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

When changing the MAJOR version of an API, ensure that **ALL** of the URLs are updated to the new MAJOR version, even if the endpoint behind some of these URLs has not been changed.

```text
v1 URLs:        https://api.swiftrefdata.com/v1/ibans/{iban}/validity
                https://api.swiftrefdata.com/v1/ibans/{iban}/bic
                https://api.swiftrefdata.com/v1/ibans/{iban}

v2 URLs:        https://api.swiftrefdata.com/v2/ibans/{iban}/validity
                https://api.swiftrefdata.com/v2/ibans/{iban}/bic
                https://api.swiftrefdata.com/v2/ibans/{iban}

v3 URLs:        https://api.swiftrefdata.com/v3/ibans/{iban}/validity
                https://api.swiftrefdata.com/v3/ibans/{iban}/bic
                https://api.swiftrefdata.com/v3/ibans/{iban}

Invalid URLs:   https://api.swiftrefdata.com/v1/ibans/{iban}/validity
                https://api.swiftrefdata.com/v2/ibans/{iban}/bic
                https://api.swiftrefdata.com/v1/ibans/{iban}
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

The MINOR version of the API may be specified in the X-API-Minor-Version HTTP response header.

```text
X-API-Minor-Version: v2.3
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Could | Could | Could |

### 5.4.3. Versioning and Release Guidelines

In a [recent survey ran by SmartBear](https://smartbear.com/resources/ebooks/the-state-of-api-2019-report), participants have responded that **versioning** is the second-most important challenge in the API world, after standardisation.

This an increase of 34%, compared to a similar survey done in 2016.

An API is a living contract, but it should be controlled.

Every SWIFT service must define a versioning strategy.

This is typically addressed during the initial design of the service.

Failure to provide a clear version-strategy communication may lead to frustrations.

Consumers and providers need to invest effort in migrating to an updated API version.

```text
Convention:     Only support the two latest MAJOR versions of the API and deprecate the older versions.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

```text
Convention:     Provide at least six months (preferably one year) notice of a new API MAJOR version.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

```text
Convention:     Never run more than two MAJOR versions of an API at the same time to avoid technical debts and reduce the risk of accidental incompatibilities.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

```text
Convention:     Document your API version strategy as early as possible and share it with your consumers.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Should | Must |

# 6. Collections

## 6.1. Sorting and Filtering

Sometimes, you need to filter and/or sort a collection of resources.

You can do it in a very inefficient way by getting the full collection of resources and doing the filtering and/or sorting on the client side or you can do the filtering and/or sorting on the server side, which is much more efficient in terms of reduced bandwidth cost, reduced latency, improved response time.

The filtering and/or sorting should be done based on some resource attributes (for example, color, region, brand, year, month, day, and so on) which should be added to the query as query parameters.

```text
Convention: 	Sorting and filtering should be done server-side by providing parameters in the query string.

Example(s): 	https://api.example.com/user-management/users?country=BE&age%3e40&sort=lastName
                Returns all users located in Belgium, older than 40, sorted by last name.
```

Some remarks about the previous URL in the example:
- BE is in upper case which seems to violate rule 4.2.5.6 Always use Lowercase Letters in URLs. It is not, because BE is a value of an attribute named country in the /users resource and not the URL of a resource.
- %3e is the URL-escaped value of the greater than symbol.
- lastName is in camel case, which seems to violate rules 4.2.5.4 Use Hyphens to improve Readability of URLs and 4.2.5.6 Always use lower-case letters in URLs. It is not, because lastName is an attribute in the /users resource and not the URL of a resource.

Query parameters must not be used for retrieving a resource by ID. That should always be done by using path parameters: https://api.example.com/user-management/users/{userId}.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Should | Should | Should |

## 6.2. Pagination

When making an API call to a resource such as **/users**, which returns all users of a system, the number of results returned can be very large.

To make results easier to handle and to reduce latency and the amount of bandwidth consumed, results should be paginated.

Typically, when a request is made to a resource such as **/users** without these query parameters, an **HTTP 303 - See Other** response should be sent with a **Location** header set to **/users?limit=25,offset=0**, for example.

This will make sure that pagination is always used.

When a paginated response is sent, the representation of the Page resource should contain:
- One **self** key containing the **/users?limit=25,offset=0** URL of this Page resource.
- One **pageOf** key containing the original/full **/users** URL that this Page is a page of.
- One **next** key containing the URL of the next Page, if available.
- One **previous** key containing the URL of the previous Page, if available.
- One **first** key containing the URL to the first Page of this collection.
- One **last** key containing the URL of the last Page of this collection.

The IANA keeps a list of the [link relationships](https://www.iana.org/assignments/link-relations/link-relations.xml).

Following is an example of pagination in action:
```text
Convention:     Use pagination by adding two query parameters to the URL:
                - <limit> to limit the number of items returned (for example, limit=25).
                - <offset> to specify the offset/starting point in the list of items (for example, offset=0).

-----------------------------------------------------------------------------------------------
HTTP REQUEST: 	GET /users HTTP/1.1
                host: usertracker.com
                accept: application/json
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
HTTP RESPONSE: 	HTTP/1.1 303 See Other
                location: https://usertracker.com/users?limit=25,offset=0
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
HTTP REQUEST:   GET /users?limit=25,offset=0 HTTP/1.1
                host: usertracker.com
                accept: application/json
-----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------
HTTP RESPONSE:  HTTP/1.1 200 OK
                content-type: application/json
                content-location: https://usertracker.com/users?limit=25,offset=0
                content-length: 23456
                {
                  "self": "https://usertracker.com/users?limit=25,offset=0",
                  "kind": "Page",
                  "pageOf": "https://usertracker.com/users",
                  "first": "https://usertracker.com/users?limit=25,offset=0",
                  "last": "https://usertracker.com/users?limit=4,offset=825",
                  "next": "https://usertracker.com/users?limit=25,offset=25",
                  "contents": [
                    {
                      "self": "https://usertracker.com/users/12344",
                      "kind": "User",
                      "name": "Steve Jobs",
                      "email": "stevejobs@apple.com"
                    },
                    {
                      "self": "https://usertracker.com/users/12345",
                      "kind": "User",
                      "name": "Tim Cook",
                      "email": "timcook@apple.com"
                    },
                    ...
                    (23 more)
                  ]
                }
-----------------------------------------------------------------------------------------------
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Should | Should | Should |

# 7. HTTP Verbs

HTTP verbs are a set of methods that can be used to perform actions on a resource identified by its URL.

You send them along with the request to tell the server what you want to do.

## 7.1. Maturity Level

In the [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html), the **Level 2 - HTTP Verbs** is the minimum maturity level for all SWIFT APIs.

At this level, the HTTP protocol is no longer used as only a transport/tunneling mechanism, but the HTTP verbs define the actions on the resources (for example, use GET when reading a resource, and use POST when creating a resource, and so on).

![RichardsonMaturityModel.png](./RichardsonMaturityModel.png)

*Richardson Maturity Model (RMM)*

### Level 0: The Swamp of Plain Old XML (POX)

This is a straightforward RPC-style system in which XML is sent back and forth.

This is similar to SOAP and XML-RPC, with the only difference that XML messages are wrapped into an HTTP "envelope".

**Only using HTTP POST and rarely HTTP GET that is, HTTP is only a transport mechanism.**

### Level 1: Resources

*Use Divide and Conquer to handle complexity by breaking one large service endpoint down into multiple resources.*

Stop making all requests to one singular service endpoint, but start "talking" to individual resources.

Each item in the response is a resource that can be addressed individually by its URL.

Resources should always be **NOUNS** (for example, /users or /payment-status) and never contain **VERBS** (for example, /getUsers or /setBIC).

There are sometimes exceptions to this rule, and VERBS may be used if they make the API's intent clearer (for example, /swift-translation-api/v1/translate instead of /swift-translation-api/v1/translation-result).

Resources uniquely identified by their URLs are similar to Objects uniquely identified by their Object Identities.

**Only using HTTP POST and rarely HTTP GET that is, HTTP is only a transport mechanism.**

### Level 2: HTTP Verbs

*Remove Unnecessary Variation by using a standard set of verbs to handle similar situations in the same way.*

Move away from the "HTTP as a transport mechanism only" and use HTTP verbs as closely as possible to how they are used in HTTP.

HTTP verbs have a strong semantic. Following is an example for the GET HTTP verb:
- GET is for reading a resource.
- GET is a safe operation that is, it does not change the state of anything.
- GET is idempotent that is, it can be called any number of times in any order and you get the same results each time.
- Because of the two preceding properties that is, safe and idempotent, GET results can be cached by any participant to reduce latency and bandwidth consumption.

This level enforces following the rules of HTTP, to take full advantage of its capabilities.

This level also makes extensive use of HTTP response/status codes to inform the client of the outcome of the HTTP request that is, either success or error.

**Enforce the use of HTTP verbs and HTTP response/status codes.**

### Level 3: Hypermedia Controls

*Introduce Discoverability by providing a way to make the APIs "self-documenting".*

Hypermedia As The Engine Of Application State (HATEOAS).

Each resource in the response must have an element property containing its URL.

Rather than you having to know where to go next, the hypermedia controls in the response tell you what you can do next that is, the response contains links to what may be possible next.

These hyperlinks in the responses can also be used as a way to advertise new capabilities offered by the APIs.

Good practice is to follow the ATOM ([RFC 4287](https://tools.ietf.org/html/rfc4287)) specification for hyperlinks in responses that is, using a link element with a uri attribute to the target URL and a rel attribute to describe the kind of relationship.

**Enforce the use of HTTP verbs and HTTP response/status codes, and include URLs for each resource in the response to tell consumers what to do/where to go next.**

### REST Uniform Interface

The REST uniform interface is based on three fundamental elements:
- Resources: Any resource is uniquely identified by a Uniform Resource Locator (URL).
- HTTP Methods/Verbs: POST, GET/HEAD, PUT/PATCH or DELETE.
- Media Types: HTTP supports content negotiation for media types of the response that is, the representation of the requested resource.

```text
Convention: 	SWIFT APIs must have at least a maturity of "Level 2: HTTP Verbs" in the Richardson Maturity Model.
                At this level, the HTTP protocol is no longer used as only a transport/tunneling mechanism, but the HTTP verbs define the actions on the resources.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

## 7.2. CRUD

CRUD stands for:
- **Create** to create a new element in a collection of elements.
- **Read** to read/retrieve an element from a collection of elements.
- **Update** to update (fully or partially) an element in a collection of elements.
- **Delete** to remove an element from a collection of elements.

CRUD defines the four basic operations for managing a collection of elements/resources/data.

Some HTTP verbs enable you to send a body along with your request.

The body contains extra information that might be required to perform a certain action.

A POST request, for example contains a body that gives the server information on what entity to create.

The below table describes the most frequently used HTTP verbs:

| HTTP Verb | Operation | Description | Request Body? | SQL | Safe | Idempotent |
| --- | --- | --- | --- | --- | --- | --- |
| POST | Create | Create a new resource | Yes | INSERT | No | No |
| GET | Read | Retrieve an existing resource | No | SELECT | Yes | Yes |
| HEAD | Read Headers | Retrieve headers of an existing resource | No | SELECT | Yes | Yes |
| PUT | Full Update | Fully update an existing resource (optionally create a new resource if it does not exist) | Yes | UPDATE | No | Yes |
| PATCH | Partial Update | Partially update an existing resource | Yes | UPDATE | No | No |
| DELETE | Delete | Delete an existing resource | No | DELETE | No | Yes |

*Do not use an HTTP verb to perform an action that does not correspond to the verb. For example, do not use a POST request to only retrieve (GET) data.*

### Safe Methods

An HTTP verb/method is safe if it does not alter the state of the server that is, if the operation is read-only.

### Idempotent Methods

An HTTP verb/method is idempotent if it can be invoked multiple times without changing the result beyond the initial application.

### 7.2.1. POST

POST can either create a new resource or update (full update) an existing one.

PUT is preferred to update (full update) an existing resource, because it is idempotent.

When a resource has been successfully created through HTTP POST, an HTTP 201 Created status code should be returned with a Location HTTP response header containing the URL to the newly created resource.

The URL in the Location header should always be absolute, to make it easier to consume by client applications.

#### HTTP POST to send data for handling without necessarily creating a new resource

From [Hypertext Transfer Protocol -- HTTP/1.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html):

```text
The action performed by the POST method might not result in a resource that can be identified by a URI.
In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
If a resource has been created on the origin server, the response should be 201 (Created) and contain a Location header.
```

Strictly speaking, using POST to send data without creating a new resource is not RESTful. The [uniform interface](https://www.gcloud.belgium.be/rest/#uniform-interface) constraint of REST imposes the POST method to create a new resource.

However, when sending a request with many parameters, you sometimes do not have the possibility to put the whole parameters in the URL, because URLs should be limited to 2000 characters.

In this situation, using POST is the only possible solution, provided that the status code returned by the API is either 200 (OK) or 204 (No Content), as described above.

Forcing the use of HTTP POST instead of HTTP GET for security reasons (for example, to avoid passing sensitive information in the URL) is [not a valid argument](https://confluence.swift.com:8443/pages/viewpage.action?pageId=125511102).

If you need to read/get a resource, you should use HTTP GET that is, adhere to the REST principles and pass any sensitive information in HTTP headers to ensure they remain protected.

Passing sensitive information in the URL is not recommended because URLs can be bookmarked and stored in log files of web servers and intermediate proxies.

### 7.2.2. GET

GET retrieves a representation of the resource identified by its URL in one of the formats listed in the Accept request header (for example, application/json).

GET becomes *conditional* if it contains at least one of the following request headers:
- **If-Modified-Since** will transfer the resource only if it has been last modified after the given date.
- **If-Unmodified-Since** will transfer the resource only if it has not been last modified after the given date.
- **If-Match** will transfer the resource only if it matches one of the listed ETags.
- **If-None-Match** will transfer the resource only if it does not match one of the listed ETags.

*An ETag (Entity Tag) is an identifier for a specific version of a resource that is, it is similar to a hash or a fingerprint of a resource.*

GET becomes *partial* if it contains a **Range** request header which returns only the part(s) of a resource specified by the value in the **Range** request header.

Responses to GET requests can be cached.

### 7.2.3. PUT/PATCH

PUT can either create a new resource or update (full update) an existing one.

PUT is idempotent.

Idempotency is the main difference between PUT versus POST requests.

Because PUT replaces an existing resource, if only a subset of data is provided, the rest will be replaced with empty/null.

Replacing the whole resource is the main difference between PUT versus PATCH requests.

PATCH only updates (partial update) the specified fields of a resource.

PATCH is not safe, because it alters the state of the server that is, a read-write operation.

PATCH is not idempotent, because invoking it multiple times may change the result beyond the initial application.

#### Concrete example of a NON idempotent PATCH request

This example uses [JSON PATCH](http://jsonpatch.com/).

JSON Patch is a format for describing changes to a JSON document. When used in combination with the HTTP PATCH method, it enables partial updates for HTTP APIs in a standards-compliant way.

JSON Patch defines several operations that is, Add, Remove, Replace, Copy, Move and Test.

Consider a Resource whose JSON Representation is:

```json
    {
      "products": [
        { "name": "iPhone" },
        { "name": "iPad" }
      ]
    }
```

Now, consider the following Add Operation:

```json
   {
     "op": "add",
     "path": "/products/1",
     "value": {
       "name": "Apple Watch"
     }
   }
```

This operation will insert the object:

```json
    {
      "name": "Apple Watch"
    }
```

Before the index 1 in the products array.
The JSON Representation of the Resource is now:

```json
    {
      "products": [
        { "name": "iPhone" },
        { "name": "Apple Watch" },
        { "name": "iPad" }
      ]
    }
```

If we send the same HTTP PATCH request again, the JSON Representation of the Resource would now be:

```json
    {
      "products": [
        { "name": "iPhone" },
        { "name": "Apple Watch" },
        { "name": "Apple Watch" },
        { "name": "iPad" }
      ]
    }
```

This example clearly shows that PATCH is NOT idempotent.

### 7.2.4. DELETE

DELETE removes the resource identified by its URL.

The resource does not have to be removed immediately that is, it could be an asynchronous or long-running process.

# 8. HTTP Headers

HTTP requests and HTTP responses have an HTTP header section.

HTTP headers enable HTTP clients and HTTP servers to communicate with each other (for example, allow a server to inform a client that it needs to provide authentication details to access a protected resource).

Header field names are [case-insensitive](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2).

Apart from that there are no clear rules, standards or RFCs define naming conventions for HTTP headers.

Either use what the majority of the industry is using, or adhere to PascalCase (also known as Upper Camel Case) naming for standard and non-standard HTTP header field names.

```text
Convention: 	Use PascalCase for HTTP headers.

Example(s): 	Accept
                Content-Type
                Authorization
```

The most common HTTP headers are described below.

Detailed information about HTTP headers can be found in [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Should | Should | Should |

## 8.1. Content-Type versus Accept

Consumers should always send an Accept header to tell the API which format/representation they prefer to receive in the response that is, it drives the Content-Type of the response.

Consumers should send a Content-Type header when the request includes an HTTP body (to specify the format/representation of the request).

Providers should send a Content-Type header when the response includes an HTTP body (to specify the format/representation of the response).

Standard media type names (such as [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)) should be used.

For JSON, it should be "application/json" with [UTF-8](https://en.wikipedia.org/wiki/UTF-8) as the default encoding.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Must | Should | Must |

## 8.2. Authorization

Most APIs require an authenticated user for security/auditing/analytics/monetising purposes.

Consumers must authenticate by providing their credentials and requesting an OAuth2 access token from the **/token** endpoint.

The acquired OAuth2 access token can then be used to authenticate and authorise the user to the other SWIFT APIs.

The OAuth2 access token must be sent by setting a "Bearer token" in the "Authorization" header:

```text
Authorization: Bearer <OAuthAccessToken>
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Must | Must | Must |

## 8.3. Host

The Host request header specifies the domain name of the server for [virtual hosting](https://en.wikipedia.org/wiki/Virtual_hosting) and, optionally, the TCP port number on which the server is listening.

If no port is given, the default port for the service requested is implied (for example, 443 for HTTPS).

A Host header field **must** be sent in **all** HTTP/1.1 request messages.

An HTTP 400 Bad Request status code will be sent to any HTTP/1.1 request message that lacks a Host header field or that contains more than one.

## 8.4. Location

The Location response header indicates the URL to redirect to.

It only provides a meaning when served with a 3xx Redirection or 201 Created status code.

## 8.5. Custom Headers

Custom headers are prefixed with 'X-', like 'X-Custom-Header'.

```text
Convention: 	Prefix custom headers with 'X-'.

Example(s): 	X-Request-ID, X-API-Minor-Version
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Must | Should | Must |

## 8.6. Trace Identifier

The ability to trace each API call that is, an API request and its associated API response is very important for troubleshooting and support purposes.

### 8.6.1. API Call Trace ID for SWIFT

The API Gateway generates a Universally Unique IDentifier (UUID) that is copied in the API request and its associated API response.

This trace identification process is done automatically by the API Gateway and requires no user and/or developer action.

This trace ID is used by SWIFT internally and not by API consumers.

### 8.6.2. API Call Trace ID for API Consumers

Using a trace ID enables API consumers to reconcile an API request with its associated API response that is, to unambiguously associate a request with its response.

This can be very useful in high concurrency/parallelism environments where multiple requests and responses can be simultaneously "in-flight".

API consumers can use the *optional* **X-Request-ID** header for this purpose.

This trace identification process works as follows:
1. The API consumer generates a UUID and assigns it to the **X-Request-ID** request header of the API request.
2. The **X-Request-ID** request header is passed unmodified to the back-end server/service that is, the API provider.
3. The back-end server/service copies the value of the **X-Request-ID** from the API request into its associated API response, as an **X-Request-ID** response header.
4. The API consumer receives the API response with an **X-Request-ID** response header containing the UUID of the initial API request, which enables it to correlate the API request with the API response.

# 9. Error Handling

Handling errors is a very important part in designing and building your API.

Using the proper HTTP status codes and clear messages to indicate errors will make your APIs easy to consume and easy to understand.

## 9.1. HTTP Status Codes

Industry best practices:
- Use well-known status codes.
- Limit the number of different status codes.
- Wrap "non-standard" status codes into standard status codes.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Must | Must | Must | Must |

### 9.1.1. Success

| HTTP Status Code | Formal Description | When to Use |
| --- | --- | --- |
| 200 | OK | Request successful. Response depends on the request method used that is, GET, POST, and so on. |
| 201 | Created | Request fulfilled. Resource created. The HTTP response should contain a **Location** HTTP header containing the URL of the newly created resource. |
| 202 | Accepted | Request queued (typically for DELETE operations). Can be used to inform the consumer that the request has been received, but will be fulfilled at a later time. |
| 204 | No Content | Request successful. Response does not contain a body. Can be used to avoid sending back the full resource following a successful PUT request when it is a large payload. |

### 9.1.2. Redirection

| HTTP Status Code | Formal Description | When to Use |
| --- | --- | --- |
| 301 | Moved Permanently | Permanent URL redirection that is, the resource has been definitively moved to the new URL. The URL used to access the resource must be updated with the value received in the **Location** HTTP header. By updating the URL to access the resource (at the client side), you ensure that any subsequent access to the resource will save one round-trip time (by avoiding the redirection). The HTTP method and HTTP body should not be altered when the redirection is performed. |
| 302 | Found | Also called Moved Temporarily. The URL in the **Location** HTTP header should be followed by the client but not used to update the original URL to the resource (the redirection is only temporary). The HTTP method and HTTP body should not be altered when the redirection is performed. |
| 303 | See Other | Resource is too large to be returned as one response. The response should be paginated. The HTTP response should contain a **Location** HTTP header containing the URL of the first page that is, specified with the **limit** and **offset** query parameters. |
| 304 | Not Modified | Resource not modified since version specified in **If-Modified-Since** or **If-None-Match**. No resource retransmit. Redirect to client-cached resource. |

### 9.1.3. Client Errors

| HTTP Status Code | Formal Description | When to Use |
| --- | --- | --- |
| 400 | Bad Request | Client error in request (for example, malformed request syntax). The client should not repeat the request without modifications. Some possible actions to [fix this error](https://www.lifewire.com/how-to-fix-a-400-bad-request-error-2617988) are: check for errors in the URL, clear cookies storage, clear DNS cache, or clear web browser cache. |
| 401 | Unauthorized | Semantically means unauthenticated that is, involving authentication or proof of identity. The response must include a **WWW-Authenticate** header field containing a challenge applicable to the requested resource. To be used when authentication is required but has failed or has not yet been provided that is, missing **Authorization** header. After receiving an HTTP 401, the client should send back an HTTP request containing an **Authorization** header. |
| 403 | Forbidden | Semantically means unauthorized that is, involving authorization or proof of access right. The request is valid, but the server is refusing action because the user either does not have necessary permissions for the resource or needs an account. At this point, the access is permanently forbidden and an action is required before the client can resend the request to this URL. |
| 404 | Not Found | Requested resource cannot be found, but may be available in the future. Subsequent requests from client are permissible. |
| 405 | Method Not Allowed |HTTP verb used to access this resource is either not supported by the provider or not authorised for the consumer. If the method requested is not allowed for the authenticated consumer, it is best to send an HTTP 405 that is, partial access to resource is forbidden. If the access to the URL is not allowed for the authenticated consumer, it is best to send an HTTP 403 that is, full access to the resource is forbidden. Response must include an **Allow** header field containing the list of methods/verbs supported by the target resource for the authenticated consumer.  |
| 406 | Not Acceptable | Server cannot produce a response that is, the representation of the requested resource matching the list of media types accepted by the client. Clients indicate the list of accepted media types in the **Accept** HTTP request header field (for example, Accept: application/json, application/xml). |
| 407 | Proxy Authentication Required | Request has not been applied because it lacks valid authentication credentials for a proxy server that is between the client and the server that can access the requested resource. Response must include a **Proxy-Authenticate** header field containing information on how to authorise correctly. |
| 409 | Conflict | Request cannot be completed due to a conflict with the current state of the target resource. Conflicts usually occur in response to PUT requests when multiple users are trying to update the same resource at the same time that is, [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control). This status code can also be used to indicate that a new resource that we are trying to create already exists (for example, trying to create a new account with an email address that is already registered). |
| 410 | Gone | Access to the target resource is no longer available at the origin server because it has been permanently deleted. Because the deletion of the resource is permanent, subsequent requests from a client are not allowed. A 404  status code must be used instead if you do not know whether the condition is temporary or permanent. |
| 413 | Payload Too Large |Indicates the server or gateway is refusing to process your request because the request payload is larger than willing or able to process. By default, the API gateway supports up to [10 MB](https://docs.apigee.com/api-platform/fundamentals/best-practices-api-proxy-design-and-development#size). |
| 429 | Too Many Requests | Indicates that the user has sent too many requests in a given amount of time. The HTTP response should contain the Retry-After HTTP header with the estimated time before making a new request. Used to [prevent DDoS attacks and for API rate limiting](https://docs.apigee.com/api-platform/develop/comparing-quota-spike-arrest-and-concurrent-rate-limit-policies.html). |

### 9.1.4. Server Errors

| HTTP Status Code | Formal Description | When to Use |
| --- | --- | --- |
| 500 | Internal Server Error | Generic server error message. |
| 503 | Service Unavailable | Server is not ready to handle the request, either because it is down for maintenance or because it is overloaded. The HTTP response should contain the **Retry-After** HTTP header with the estimated time for the recovery of the service. |
| 504 | Gateway Timeout | Indicates that a server, acting as a proxy/gateway, did not receive a response from the main server within a set time period. |

### 9.1.5. 200-OK versus 201-Created versus 204-No Content

From [RFC2616 section 9.5](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5).

The action performed by the POST method might not result in a resource that can be identified by a URL.
In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.

![200-201-204.png](./200-201-204.png)

*200 versus 201 versus 204*

## 9.2. Error Messages

In case of error, every API should return a clear descriptive error message in the response body.

```text
Convention: 	In case of error, always use the standard error message structure in the response body.

Example(s): 	HTTP Status Code (4xx or 5xx)
                Error Message (in JSON format):
                {
                    "code": "SwAP5xx",
                    "severity": "Fatal",
                    "text": "Verbose, human-readable description of the problem for the application developer with hints about how to fix it.",
                    "user_message": "Message to be passed to the application user, if needed.",
                    "more_info": "https://developer.swift.com/errors/SwAP/5xx"
                }
```

| Field | Mandatory | Description |
| --- | --- | --- |
| code | Yes | Unique identifier for errors. Should contain an indication of which system/application/component/sub-component is throwing the error. |
| severity | Yes | Severity of the error. Either Fatal, Transient or Logic. |
| text | Yes | Textual description of the error. |
| user_message | No | Can contain a message to be passed to the application user. |
| more_info | No | Can contain a URL to more information about the error. |

The **code** field:
- Can be used to identify either an API gateway error or an application-specific error.
- Does not replace the HTTP status code.

JSON Schema for the Error Message Structure:

```json
    {
        "$schema": "https://json-schema.org/draft-07/schema#",
        "$id": "https://developer.swift.com/error-message.schema.json",
        "title": "Error Message",
        "description": "An error message returned by either the API gateway or the API backend server.",
        "type": "object",
        "properties": {
            "code": {
                "type": "string",
                "description": "The unique identifier of the error. It should contain an indication of which system/application/component/sub-component is throwing the error."
            },
            "severity": {
                "type": "string",
                "enum": ["Fatal", "Transient", "Logic"],
                "description": "The severity of the error."
            },
            "text": {
                "type": "string",
                "description": "The verbose human-readable description of the problem for the application developer with hints about how to fix it."
            },
            "user_message": {
                "type": "string",
                "description": "The message to be passed to the application user, if needed."
            },
            "more_info": {
                "type": "string",
                "description": "The URL link to more information about the error (for example, https://developer.swift.com/errors/SwAP/12345)."
            }
        },
        "required": ["code", "severity", "text"]
    }
```

The HTTP status code only does not provide enough information to determine if the error is related to the API Gateway or one of the back-end services behind it.

Each error code should ideally have an associated web page that is, the URL in the more_info field of the error message describing the problem and giving suggestions on how to solve it.

Never ever return stack traces, because they may contain sensitive information about the back-end service.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Must | Should | Must |

## 9.3. API Gateway Errors

The table below contains the error codes returned by the old SwAP API Gateway.

They will be removed in the future, when SWIFT will only use the new APIGEE API Gateway.

| Error Code | Error Severity | Error Text | HTTP Status Code |
| --- | --- | --- | --- |
| SwAP001 | Fatal | API Service not provisioned  | 401 Unauthorized |
| SwAP002 | Fatal | Invalid OAuth Token | 401 Unauthorized |
| SwAP003 | Fatal | OAuth access token has insufficient scope for the requested service | 401 Unauthorized |
| SwAP008 | Fatal | Invalid response received from Service Provider | 502 Bad Gateway |

The table below contains the error codes returned by the new APIGEE API Gateway.

All error codes starting with SwAP5xx are coming the new APIGEE API Gateway.

| Error Code | Error Severity | Error Text | HTTP Status Code |
| --- | --- | --- | --- |
| SwAP501 | Fatal | APIRequestIsMalformed | 400 Bad Request |
| SwAP502 | Fatal | InvalidOAuthToken | 401 Unauthorized |
| SwAP503 | Fatal | OAuthTokenHasInsufficientScopeForRequestedService | 403 Forbidden |
| SwAP504 | Fatal | RequestBodyIsNotWellFormed | 400 Bad Request |
| SwAP506 | Fatal | ResourceDoesNotExist | 404 Not Found |
| SwAP507 | Transient | RequestCannotBeProcessedAtThisTime | 429 Too Many Requests |
| SwAP508 | Fatal | OAuthTokenNotProvided | 401 Unauthorized |
| SwAP509 | Fatal | Missing mandatory signature on the non-repudiation API transaction | 400 Bad Request |
| SwAP510 | Fatal | The API method does not support non-repudiation | 400 Bad Request |
| SwAP521 | Fatal | XBICHeaderNotIncluded | 400 Bad Request |
| SwAP522 | Fatal | XBICHeaderNotValid | 400 Bad Request |
| SwAP590 | Transient | ServiceTemporarilyUnavailable | 503 Service Unavailable |
| SwAP591 | Transient | ServiceProviderTimeOut | 504 Gateway Timeout |
| SwAP599 | Fatal | UnexpectedError | 500 Internal Server Error |

## 9.4. Back-end Errors

Each back-end service must provide a full list of clearly defined error codes with associated web pages describing the error and how to solve it.

Each error from back-end services must follow the structure defined in paragraph 9.2 Error Messages.

This is a strong requirement for any existing and new API.

```text
Convention: 	Back-end services must follow the Error Message structure defined in paragraph 9.2 Error Messages.
```

```text
Convention: 	Back-end services must provide their full/complete list of error codes.
```

# 10. API Specification

Each API must be defined in the [OpenAPI Specification (OAS) version 3](https://swagger.io/docs/specification).

The API specification must be created in [SwaggerHub](https://app.swaggerhub.com).

Currently, SWIFT uses the Cloud version of SwaggerHub, but in the future an On-Premises version of SwaggerHub will be available.

Once the API specification is published in SwaggerHub, it must be made available on the [SWIFT Developer Portal](https://developer.swift.com).

The OAS document describes all resources and their associated operations (CRUD).

The OpenAPI Specification version 3 is defined in [GitHub](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md).

```text
Convention: 	Each API must be defined in the OpenAPI Specification version 3.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Should | Must | Must |

```text
Convention: 	Each API specification must be created in SwaggerHub.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Should | Must | Must |

```text
Convention: 	Each published API must be made available in the SWIFT Developer Portal.
```

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Could | Should | Must | Must |

# 11. API Testing

A [Postman](https://www.getpostman.com) collection must be made available with every API.

The Postman collection should at least contain the following:
- Calls for all of the happy paths/flows in the API (for example, create a new resource, retrieve an existing resource, update an existing resource, delete an existing resource).
- Calls to test the North-bound Security that is, HTTP Bearer Authentication.
- Calls to check for invalid/unsupported HTTP Verbs.

| Internal | Private | Partner | Open |
| --- | --- | --- | --- |
| Should | Must | Must | Must |

